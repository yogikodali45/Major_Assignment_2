<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Massachusetts Maps — Population & Gini</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #f9fafb;
      color: #111827;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    h2 {
      margin-top: 2rem;
      margin-bottom: 0.75rem;
    }
    .map-container {
      background: #ffffff;
      border-radius: 0.75rem;
      padding: 1rem 1.25rem 1.5rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
      margin-bottom: 1.5rem;
    }
    .town {
      stroke: #1f2937;
      stroke-width: 0.5;
    }
    #tooltip {
      position: fixed;
      pointer-events: none;
      background: #ffffff;
      border-radius: 0.5rem;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
      padding: 0.75rem 0.9rem;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 9999;
      max-width: 320px;
      border: 1px solid #e5e7eb;
    }
    #tt-title {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 0.2rem;
    }
    #tt-meta {
      font-size: 0.8rem;
      color: #4b5563;
      margin-bottom: 0.4rem;
    }
  </style>

  <!-- D3 & TopoJSON from CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
</head>
<body>
  <h1>Massachusetts Population & Inequality Maps</h1>
  <p style="max-width: 700px; font-size:0.9rem; color:#4b5563;">
    Map A shows town-level population in 1980, Map B shows population change between 1980 and 2010,
    and Map C shows the county Gini index (with a time-series tooltip).
  </p>

  <!-- MAP A -->
  <div id="mapA" class="map-container"></div>

  <!-- MAP B -->
  <div id="mapB" class="map-container"></div>

  <!-- MAP C -->
  <div id="mapC" class="map-container"></div>

  <!-- Tooltip for MAP C -->
  <div id="tooltip">
    <div id="tt-title"></div>
    <div id="tt-meta"></div>
    <svg id="tt-chart" width="260" height="160"></svg>
  </div>

  <script>
    // Small helper
    const pick = (obj, cands) => cands.find(k => Object.prototype.hasOwnProperty.call(obj, k));

    // ===== MAP A: Population in 1980 by town =====
    (async function () {
      const mapASection = document.querySelector("#mapA");
      mapASection.innerHTML = `<h2>MAP A — Population (1980) by Town</h2>`;

      // 1) Load the TopoJSON
      let topo;
      try {
        topo = await d3.json("towns.topojson");
      } catch (e) {
        console.error(e);
        mapASection.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Could not load <code>towns.topojson</code>. Check the file path/name.
          </p>`
        );
        return;
      }

      // 2) Convert TopoJSON -> GeoJSON
      const objectName = Object.keys(topo.objects)[0];
      const geo = topojson.feature(topo, topo.objects[objectName]);
      const features = geo.features;
      if (!features || !features.length) {
        mapASection.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">No features found in towns.topojson.</p>`
        );
        return;
      }

      // 3) Find property names (robust to naming)
      const props0 = features[0].properties || {};
      console.log("MAP A — sample town properties:", props0);
      const P80 = pick(props0, ["POP1980", "pop1980", "POP_1980", "P1980"]);
      const TOWN_NAME = pick(props0, ["TOWN", "Town", "NAME", "PLACE"]);

      if (!P80) {
        mapASection.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Expected a 1980 population field (e.g., <code>POP1980</code>) in towns.topojson.
          </p>`
        );
        return;
      }

      // 4) SVG + projection
      const W = 1000, H = 640;
      const svg = d3.select("#mapA")
        .append("svg")
        .attr("viewBox", [0, 0, W, H])
        .style("width", "100%")
        .style("height", "auto");

      const projection = d3.geoMercator()
        .fitExtent([[20, 20], [W - 20, H - 20]], geo);
      const path = d3.geoPath(projection);

      // 5) Color scale
      const popExtent = d3.extent(features, f => +f.properties[P80] || 0);
      const colorA = d3.scaleSequential()
        .domain(popExtent)
        .interpolator(d3.interpolateBlues);

      // 6) Draw towns
      const g = svg.append("g");
      g.selectAll("path")
        .data(features)
        .join("path")
        .attr("class", "town")
        .attr("d", path)
        .attr("fill", d => colorA(+d.properties[P80] || 0))
        .on("mouseenter", function (e, d) {
          d3.select(this).raise().attr("stroke", "#111827").attr("stroke-width", 1.6);
          if (TOWN_NAME) {
            svg.selectAll(".mapA-label").remove();
            svg.append("text")
              .attr("class", "mapA-label")
              .attr("x", 24).attr("y", 34)
              .attr("font-weight", 700)
              .attr("font-size", 14)
              .text(`${d.properties[TOWN_NAME]} — 1980: ${+d.properties[P80] || 0}`);
          }
        })
        .on("mouseleave", function () {
          d3.select(this).attr("stroke", "#1f2937").attr("stroke-width", 0.5);
          svg.selectAll(".mapA-label").remove();
        });

      // 7) Legend
      const legend = svg.append("g").attr("transform", "translate(16,16)");
      const n = 180, w = 220, h = 12, sw = w / n;
      for (let i = 0; i < n; i++) {
        const t = i / (n - 1);
        const v = popExtent[0] + t * (popExtent[1] - popExtent[0]);
        legend.append("rect")
          .attr("x", i * sw).attr("y", 0)
          .attr("width", sw + 0.5).attr("height", h)
          .attr("fill", colorA(v));
      }
      const axis = d3.axisBottom(
        d3.scaleLinear().domain(popExtent).range([0, w])
      ).ticks(5).tickSize(4);
      legend.append("g").attr("transform", `translate(0,${h})`).call(axis);
      legend.append("text")
        .attr("x", 0).attr("y", -4).attr("font-weight", 700)
        .text("Population (1980)");
    })();


    // ===== MAP B: Population Change (1980 → 2010) by town =====
    (async function () {
      const section = document.querySelector("#mapB");
      section.innerHTML = `<h2>MAP B — Population Change (1980 → 2010) by Town</h2>`;

      let topo;
      try {
        topo = await d3.json("towns.topojson");
      } catch (e) {
        console.error(e);
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Could not load <code>towns.topojson</code> for MAP B.
          </p>`
        );
        return;
      }

      const objectName = Object.keys(topo.objects)[0];
      const geo = topojson.feature(topo, topo.objects[objectName]);
      const features = geo.features;

      if (!features?.length) {
        section.insertAdjacentHTML("beforeend", `<p style="color:#b91c1c">No features found.</p>`);
        return;
      }

      const props0 = features[0].properties || {};
      console.log("MAP B — sample town properties:", props0);
      const P80 = pick(props0, ["POP1980", "pop1980", "POP_1980", "P1980"]);
      const P10 = pick(props0, ["POP2010", "pop2010", "POP_2010", "P2010"]);

      if (!P80 || !P10) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Missing fields. Need both <code>POP1980</code> and <code>POP2010</code> (or equivalents).
          </p>`
        );
        return;
      }

      const W = 1000, H = 640;
      const svg = d3.select("#mapB").append("svg")
        .attr("viewBox", [0, 0, W, H])
        .style("width", "100%")
        .style("height", "auto");

      const projection = d3.geoMercator()
        .fitExtent([[20, 20], [W - 20, H - 20]], geo);
      const path = d3.geoPath(projection);

      // Diverging color scale
      const changes = features.map(f => (+f.properties[P10] || 0) - (+f.properties[P80] || 0));
      const maxAbs = d3.max(changes, v => Math.abs(v)) || 1;
      const colorB = d3.scaleDiverging()
        .domain([-maxAbs, 0, maxAbs])
        .interpolator(d3.interpolateRdBu);

      svg.append("g").selectAll("path")
        .data(features)
        .join("path")
        .attr("class", "town")
        .attr("d", path)
        .attr("fill", d => {
          const v = (+d.properties[P10] || 0) - (+d.properties[P80] || 0);
          return colorB(v);
        })
        .on("mouseenter", function () {
          d3.select(this).raise().attr("stroke", "#111827").attr("stroke-width", 1.6);
        })
        .on("mouseleave", function () {
          d3.select(this).attr("stroke", "#1f2937").attr("stroke-width", 0.5);
        });

      // Legend
      const g = svg.append("g").attr("transform", "translate(16,16)");
      const n = 180, w = 220, h = 12, sw = w / n;
      for (let i = 0; i < n; i++) {
        g.append("rect")
          .attr("x", i * sw).attr("y", 0).attr("width", sw + 0.5).attr("height", h)
          .attr("fill", d3.interpolateRdBu(i / (n - 1)));
      }
      const scale = d3.scaleLinear().domain([-maxAbs, maxAbs]).range([0, w]);
      const ax = d3.axisBottom(scale).tickValues([-maxAbs, 0, maxAbs]).tickSize(4);
      g.append("g").attr("transform", `translate(0,${h})`).call(ax);
      g.append("text").attr("x", 0).attr("y", -4).attr("font-weight", 700)
        .text("Population Change (1980 → 2010)");
    })();


    // ===== MAP C: County Gini (2019), tooltip shows time series =====
    (async function () {
      const section = document.querySelector("#mapC");
      section.innerHTML = `<h2>MAP C — County Gini (2019)</h2>`;

      // --- 1) Load towns TopoJSON ---
      let topo;
      try {
        topo = await d3.json("towns.topojson");
      } catch (e) {
        console.error(e);
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Could not load <code>towns.topojson</code> for MAP C.
          </p>`
        );
        return;
      }

      const objectName = Object.keys(topo.objects)[0];
      const geo = topojson.feature(topo, topo.objects[objectName]);
      const features = geo.features;
      if (!features?.length) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">No features found.</p>`
        );
        return;
      }

      const props0 = features[0].properties || {};
      console.log("MAP C — sample town properties:", props0);
      const COUNTY_FIPS_KEY = pick(props0, ["FIPS_STCO", "COUNTYFIPS", "FIPS", "FIPS_ST"]);

      const W = 1000, H = 640;
      const svg = d3.select("#mapC").append("svg")
        .attr("viewBox", [0, 0, W, H])
        .style("width", "100%")
        .style("height", "auto");

      const projection = d3.geoMercator().fitExtent([[20, 20], [W - 20, H - 20]], geo);
      const path = d3.geoPath(projection);

      function drawBasemap(fill = "#e5e7eb") {
        svg.append("g").selectAll("path")
          .data(features)
          .join("path")
          .attr("class", "town")
          .attr("d", path)
          .attr("fill", fill)
          .attr("stroke", "#1f2937")
          .attr("stroke-width", 0.5);
      }

      if (!COUNTY_FIPS_KEY) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Could not find a county FIPS field in <code>towns.topojson</code>.<br>
            Keys found: <code>${Object.keys(props0).join(", ")}</code>
          </p>`
        );
        drawBasemap();
        return;
      }

      // --- 2) Load Gini CSV ---
      let raw;
      try {
        raw = await d3.csv("gini_index.csv");
      } catch (e) {
        console.error(e);
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Could not load <code>gini_index.csv</code>.
          </p>`
        );
        drawBasemap();
        return;
      }

      if (!raw.length) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            <code>gini_index.csv</code> is empty or could not be parsed.
          </p>`
        );
        drawBasemap();
        return;
      }

      console.log("MAP C — sample Gini row:", raw[0]);
      console.log("MAP C — CSV columns:", raw.columns);

      // --- 3) Normalize rows → {fips, name, year, gini} ---
      let rows = [];

      if ("id" in raw[0] && "Estimate!!Gini Index" in raw[0]) {
        // ACS-like format
        rows = raw.map(r => {
          const m = String(r.id).match(/(\d{5})$/);
          const fips = m ? +m[1] : NaN;
          return {
            fips,
            name: r["Geographic Area Name"] || "",
            year: +r.year,
            gini: +r["Estimate!!Gini Index"]
          };
        }).filter(r => r.fips && !Number.isNaN(r.year) && !Number.isNaN(r.gini));
      } else if ("fips_code" in raw[0] && "gini" in raw[0] && "year" in raw[0]) {
        // Already tidy
        rows = raw.map(r => ({
          fips: +r.fips_code,
          name: r.county || "",
          year: +r.year,
          gini: +r.gini
        })).filter(r => r.fips && !Number.isNaN(r.year) && !Number.isNaN(r.gini));
      } else if ("fips_code" in raw[0]) {
        // Wide format: fips_code, county, 2006..2019
        const yearCols = raw.columns.filter(c => /^\d{4}$/.test(c));
        rows = [];
        raw.forEach(r => {
          const fips = +r.fips_code;
          if (!fips) return;
          const name = r.county || "";
          yearCols.forEach(y => {
            const v = +r[y];
            if (!Number.isNaN(v)) {
              rows.push({ fips, name, year: +y, gini: v });
            }
          });
        });
      }

      if (!rows.length) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            Parsed 0 valid Gini rows from <code>gini_index.csv</code> — please check the column names.
          </p>`
        );
        drawBasemap();
        return;
      }

      // --- 4) Group by FIPS ---
      const byFips = new Map();
      d3.groups(rows, d => d.fips).forEach(([fips, arr]) => {
        arr.sort((a, b) => d3.ascending(a.year, b.year));
        const series = arr.map(d => ({ year: d.year, gini: d.gini }));
        const r2019 = arr.find(d => d.year === 2019);
        byFips.set(+fips, {
          name: arr[0]?.name || `County FIPS ${fips}`,
          series,
          gini2019: r2019 ? r2019.gini : (series[series.length - 1]?.gini ?? NaN)
        });
      });

      const vals2019 = Array.from(byFips.values(), v => v.gini2019).filter(v => !Number.isNaN(v));
      if (!vals2019.length) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c">
            No valid 2019 Gini values found in <code>gini_index.csv</code>.
          </p>`
        );
        drawBasemap();
        return;
      }

      const gExt = d3.extent(vals2019);
      const hue = d3.scaleLinear().domain(gExt).range([100, 300]);
      const colorC = v => Number.isNaN(v) ? "#e2e8f0" : d3.hsl(hue(v), 0.65, 0.5).toString();

      // Tooltip handles
      const tooltip = d3.select("#tooltip");
      const ttTitle = d3.select("#tt-title");
      const ttMeta = d3.select("#tt-meta");
      const ttChart = d3.select("#tt-chart");
      const ttW = +ttChart.attr("width") || 260;
      const ttH = +ttChart.attr("height") || 160;
      const pad = { top: 12, right: 10, bottom: 18, left: 32 };

      function drawTT(series) {
        ttChart.selectAll("*").remove();
        if (!series || !series.length) return;
        const x = d3.scaleLinear()
          .domain(d3.extent(series, d => d.year))
          .range([pad.left, ttW - pad.right]);
        const y = d3.scaleLinear()
          .domain(d3.extent(series, d => d.gini)).nice()
          .range([ttH - pad.bottom, pad.top]);

        ttChart.append("g")
          .attr("transform", `translate(0,${ttH - pad.bottom})`)
          .call(d3.axisBottom(x).ticks(5).tickFormat(d3.format("d")));

        ttChart.append("g")
          .attr("transform", `translate(${pad.left},0)`)
          .call(d3.axisLeft(y).ticks(4));

        const line = d3.line()
          .x(d => x(d.year))
          .y(d => y(d.gini));

        ttChart.append("path")
          .datum(series)
          .attr("fill", "none")
          .attr("stroke", "#0f172a")
          .attr("stroke-width", 1.6)
          .attr("d", line);
      }

      // --- 5) Draw map with Gini choropleth ---
      let matchedCount = 0;

      svg.append("g").selectAll("path")
        .data(features)
        .join("path")
        .attr("class", "town")
        .attr("d", path)
        .attr("fill", d => {
          const fips = +d.properties[COUNTY_FIPS_KEY];
          const rec = byFips.get(fips);
          if (rec) matchedCount++;
          return rec ? colorC(rec.gini2019) : "#e2e8f0";
        })
        .attr("stroke", "#1f2937")
        .attr("stroke-width", 0.5)
        .on("mouseenter", function (e, d) {
          d3.select(this).raise().attr("stroke", "#111827").attr("stroke-width", 1.6);
          const fips = +d.properties[COUNTY_FIPS_KEY];
          const rec = byFips.get(fips);
          const name = rec?.name || `County FIPS ${fips}`;
          ttTitle.text(name);
          const g2019 = rec?.gini2019;
          ttMeta.text(
            Number.isNaN(g2019) ? "No Gini data." : `Gini (2019): ${d3.format(".3f")(g2019)}`
          );
          drawTT(rec?.series || []);
          tooltip
            .style("opacity", 1)
            .style("left", (e.clientX + 16) + "px")
            .style("top", (e.clientY + 12) + "px");
        })
        .on("mousemove", function (e) {
          tooltip
            .style("left", (e.clientX + 16) + "px")
            .style("top", (e.clientY + 12) + "px");
        })
        .on("mouseleave", function () {
          d3.select(this).attr("stroke", "#1f2937").attr("stroke-width", 0.5);
          tooltip.style("opacity", 0);
        });

      if (!matchedCount) {
        section.insertAdjacentHTML(
          "beforeend",
          `<p style="color:#b91c1c;margin-top:0.5rem;">
            Warning: No FIPS codes in <code>towns.topojson</code> matched any FIPS codes in
            <code>gini_index.csv</code>.
          </p>`
        );
      }

      // --- 6) Legend ---
      const g = svg.append("g").attr("transform", "translate(16,16)");
      const n = 180, w = 220, h = 12, sw = w / n;
      for (let i = 0; i < n; i++) {
        const t = i / (n - 1);
        const v = gExt[0] + t * (gExt[1] - gExt[0]);
        g.append("rect")
          .attr("x", i * sw)
          .attr("y", 0)
          .attr("width", sw + 0.5)
          .attr("height", h)
          .attr("fill", colorC(v));
      }
      const scale = d3.scaleLinear().domain(gExt).range([0, w]);
      g.append("g")
        .attr("transform", `translate(0,${h})`)
        .call(d3.axisBottom(scale).ticks(5).tickSize(4));
      g.append("text")
        .attr("x", 0)
        .attr("y", -4)
        .attr("font-weight", 700)
        .text("Gini Index (2019)");
    })();
  </script>
</body>
</html>

